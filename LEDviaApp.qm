<?xml version="1.0" encoding="UTF-8"?>
<model version="4.0.3" links="0">
 <documentation>Prototyp of controlling a LED stripe with an Arduino from a handy with Bluetooth communication.
Because of the reason that the Bluetooth communication needs interrupts but the controlling of the LED stripe forbids it the communication and the controlling has to be split into two branches.

The app sends only one char byte as a request, because that reaches the Serial receive Buffer by hardware design (max. two bytes are possible).

To set the 120 pixel LED stripe there are around 369 µs of time needed (according to Nick Gammon).
The communication check time tick has to be longer than this to not disturb the setting. For now the communication tick is 20 ms long.

Calculations:
1 SPI bit = two processor clock cycles = 16 MHz / 2 = 8 MHz = 8000000 * 1 / s = 1 / 8000000 s = 0,000000125 s = 0,000125 µs = 0,125 ms = 125 ns
1 byte = 8 * SPI bit = 8 * 125 ns = 1000 ns
1 rgb-pixel = 3 * byte = 3 * 1000 ns = 3000 ns
120 rgb-pixel = 120 * rgb-pixel = 120 * 3000 ns = 360000 ns = 360 µs = 0,36 ms
LED stripe setzen = 120 prgb-ixel + 9 µs reset = 360 µs + 9 µs = 369 µs = 0,369 ms

The stopping of the communication tick with &quot;QActive_disarmX((QActive *)me, 0U);&quot; is optinal because the timer is an one shot event. But the author of the framework supposes it because of a clean programming.</documentation>
 <framework name="qpn"/>
 <package name="AOs" stereotype="0x02">
  <class name="LEDviaApp" superclass="qpn::QActive">
   <documentation>use for debuging:
digitalWrite(LED_L, HIGH);
digitalWrite(LED_L, LOW);</documentation>
   <attribute name="value" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>for all transmited values</documentation>
   </attribute>
   <attribute name="red" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>for the transmited red value</documentation>
   </attribute>
   <attribute name="green" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>for the transmited green value</documentation>
   </attribute>
   <attribute name="blue" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>for the transmited blue value</documentation>
   </attribute>
   <attribute name="program" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>for the transmited program</documentation>
   </attribute>
   <attribute name="led_index" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>index of the LED in the stripe</documentation>
   </attribute>
   <attribute name="led_x" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>processed LED of the stripe</documentation>
   </attribute>
   <attribute name="run_fwd" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>flag for running light direction
0U = forward, else backward</documentation>
   </attribute>
   <attribute name="run_nr" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>number of LED that run</documentation>
   </attribute>
   <attribute name="run_nr_index" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>index of the LED of the running group</documentation>
   </attribute>
   <attribute name="brightness" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>for the brightness value</documentation>
   </attribute>
   <attribute name="dim_up" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>flag for dimming direction
0U = up, else down</documentation>
   </attribute>
   <attribute name="rain_x" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>variable of Nick Gammon's rainbow</documentation>
   </attribute>
   <statechart>
    <initial target="../1">
     <initial_glyph conn="2,2,4,3,2,2">
      <action box="1,-2,4,2"/>
     </initial_glyph>
    </initial>
    <state name="branch">
     <documentation>First it is checked whether there is a request from the handy in the receive buffer of the USART. If so a transmit order is send to the handy and it is changed into the communication state. If not it is changed into  the active program substate.

Periodically a time tick is generated to recheck the receive buffer. This timer is also used to progress the LED programs with animations.</documentation>
     <entry brief="communication check, program choice, start communication tick">if (Serial.read() == 'R') {
    Serial.print(F(&quot;T&quot;));
    QACTIVE_POST((QActive *)me, COMMUNICATION_SIG, 0U);
}
else {
    if (me-&gt;program == 1)
        QACTIVE_POST((QActive *)me, DISPLAY_SIG, 0U);
    else if (me-&gt;program == 2) {
        if (!me-&gt;run_nr) {
            me-&gt;run_nr = 1U;
            }
        QACTIVE_POST((QActive *)me, RUNNING_SIG, 0U);
        }
    else if (me-&gt;program == 3) {
        me-&gt;run_nr++;
        me-&gt;program = 2U;
        QACTIVE_POST((QActive *)me, RUNNING_SIG, 0U);
        }
    else if (me-&gt;program == 4) {
        me-&gt;run_nr--;
        me-&gt;program = 2U;
        QACTIVE_POST((QActive *)me, RUNNING_SIG, 0U);
        }
    else if (me-&gt;program == 5)
        QACTIVE_POST((QActive *)me, DIMMING_SIG, 0U);
    else if (me-&gt;program == 6)
        QACTIVE_POST((QActive *)me, RAINBOW_SIG, 0U);
}

QActive_armX((QActive *)me, 0U, COMMUNICATION_TICK, 0U);</entry>
     <exit brief="stop communication tick">QActive_disarmX((QActive *)me, 0U);</exit>
     <tran trig="COMMUNICATION" target="../../2">
      <tran_glyph conn="4,16,3,3,42">
       <action box="0,-2,14,2"/>
      </tran_glyph>
     </tran>
     <tran trig="DISPLAY" target="../6">
      <tran_glyph conn="4,20,3,3,22">
       <action box="0,-2,9,2"/>
      </tran_glyph>
     </tran>
     <tran trig="RUNNING">
      <choice target="../../7">
       <guard brief="fwd">!me-&gt;run_fwd</guard>
       <choice_glyph conn="16,28,5,3,10">
        <action box="1,-2,6,2"/>
       </choice_glyph>
      </choice>
      <choice target="../../8">
       <guard brief="bwd">else</guard>
       <choice_glyph conn="16,28,4,3,16,10">
        <action box="0,14,6,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="4,28,3,-1,12">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <tran trig="DIMMING">
      <choice target="../../9">
       <guard brief="dim_up">!me-&gt;dim_up</guard>
       <choice_glyph conn="16,60,5,3,10">
        <action box="1,-2,8,2"/>
       </choice_glyph>
      </choice>
      <choice target="../../10">
       <guard brief="dim_down">else</guard>
       <choice_glyph conn="16,60,4,3,16,10">
        <action box="0,14,10,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="4,60,3,-1,12">
       <action box="0,-2,8,2"/>
      </tran_glyph>
     </tran>
     <tran trig="RAINBOW" target="../11">
      <tran_glyph conn="4,92,3,3,22">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <tran trig="Q_TIMEOUT" target="..">
      <tran_glyph conn="42,100,1,3,-38">
       <action box="-10,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state name="display">
      <entry brief="display LED">showColor(PIXELS, me-&gt;red, me-&gt;green, me-&gt;blue);</entry>
      <state_glyph node="26,18,14,6">
       <entry box="1,2,13,2"/>
      </state_glyph>
     </state>
     <state name="running_fwd">
      <documentation>First build into in-memory array, as these calculations take too long to do on the fly

Because of the strict timing of the SPI bus while sending the colour values to the whole LED stripe the interrupts has to be shut off. At the end of the sending a short blocking dealy is necessary as a reset for the stripe to show the colours (s. Nick Gammon).

At exit the processed LED is incremented.
If the processed LED reaches the end of the stripe, the direction flag is set true to change the direction.</documentation>
      <entry brief="running LED">for (me-&gt;led_index = 0U; me-&gt;led_index &lt; PIXELS; me-&gt;led_index++) {
    if (me-&gt;led_index == me-&gt;led_x) {
        for (me-&gt;run_nr_index = 0U;
            (me-&gt;run_nr_index &lt; me-&gt;run_nr) &amp; (me-&gt;led_index &lt; PIXELS);
            me-&gt;run_nr_index++, me-&gt;led_index++) {
                pixelArray [me-&gt;led_index].r = me-&gt;red;
                pixelArray [me-&gt;led_index].g = me-&gt;green;
                pixelArray [me-&gt;led_index].b = me-&gt;blue;
            }
        me-&gt;led_index--; // otherwise led_index would be two times counted
    }
    else {
        pixelArray [me-&gt;led_index].r = 0U;
        pixelArray [me-&gt;led_index].g = 0U;
        pixelArray [me-&gt;led_index].b = 0U;
    }
}

QF_INT_DISABLE();
for (me-&gt;led_index = 0; me-&gt;led_index &lt; PIXELS; me-&gt;led_index++) {
    sendPixel (pixelArray [me-&gt;led_index].r, pixelArray [me-&gt;led_index].g, pixelArray [me-&gt;led_index].b);
}
QF_INT_ENABLE();

show();</entry>
      <exit brief="inc processed LED, check direction">me-&gt;led_x++;

if (me-&gt;led_x &gt; PIXELS - me-&gt;run_nr) {
    me-&gt;run_fwd = 1U;
}</exit>
      <state_glyph node="26,26,14,14">
       <entry box="1,2,11,4"/>
       <exit box="1,6,12,6"/>
      </state_glyph>
     </state>
     <state name="running_bwd">
      <documentation>First build into in-memory array, as these calculations take too long to do on the fly

Because of the strict timing of the SPI bus while sending the colour values to the whole LED stripe the interrupts has to be shut off. At the end of the sending a short blocking dealy is necessary as a reset for the stripe to show the colours (s. Nick Gammon).

At exit the processed LED is decremented.
If the processed LED reaches the beginning of the stripe, the direction flag is set false to change the direction.</documentation>
      <entry brief="running LED">for (me-&gt;led_index = 0U; me-&gt;led_index &lt; PIXELS; me-&gt;led_index++) {
    if (me-&gt;led_index == me-&gt;led_x - me-&gt;run_nr) {
        for (me-&gt;run_nr_index = 0U;
            me-&gt;run_nr_index &lt; me-&gt;run_nr;
            me-&gt;run_nr_index++, me-&gt;led_index++) {
                pixelArray [me-&gt;led_index].r = me-&gt;red;
                pixelArray [me-&gt;led_index].g = me-&gt;green;
                pixelArray [me-&gt;led_index].b = me-&gt;blue;
            }
        me-&gt;led_index--; // otherwise led_index would be two times counted
    }
    else {
        pixelArray [me-&gt;led_index].r = 0U;
        pixelArray [me-&gt;led_index].g = 0U;
        pixelArray [me-&gt;led_index].b = 0U;
    }
}

QF_INT_DISABLE();
for (me-&gt;led_index = 0; me-&gt;led_index &lt; PIXELS; me-&gt;led_index++) {
    sendPixel (pixelArray [me-&gt;led_index].r, pixelArray [me-&gt;led_index].g, pixelArray [me-&gt;led_index].b);
}
QF_INT_ENABLE();

show();</entry>
      <exit brief="dec processed LED, check direction">me-&gt;led_x--;

// if (me-&gt;led_x &lt; me-&gt;run_nr) {
if (me-&gt;led_x == 0U) {
    me-&gt;run_fwd = 0U;
}</exit>
      <state_glyph node="26,42,14,14">
       <entry box="1,2,11,4"/>
       <exit box="1,6,13,6"/>
      </state_glyph>
     </state>
     <state name="dimming_up">
      <documentation>The colours are multiplicated with an incrementing brightness value.

At exit the brightness is incremented.
If the brightness reaches an upper limit, the direction flag is set true to change the direction.</documentation>
      <entry brief="dimming LED">showColor(PIXELS,
    me-&gt;red / 255.0 * me-&gt;brightness,
    me-&gt;green / 255.0 * me-&gt;brightness,
    me-&gt;blue / 255.0 * me-&gt;brightness);</entry>
      <exit brief="inc brightness, check dimming direction">me-&gt;brightness = me-&gt;brightness + 8U;

if (me-&gt;brightness &gt; 246U) {
    me-&gt;dim_up = 1U;
}</exit>
      <state_glyph node="26,58,14,14">
       <entry box="1,2,13,4"/>
       <exit box="1,6,13,6"/>
      </state_glyph>
     </state>
     <state name="dimming_down">
      <documentation>The colours are multiplicated with an decrementing brightness value.

At exit the brightness is decremented.
If the brightness reaches a lower limit, the direction flag is set false to change the direction.</documentation>
      <entry brief="dimming LED">showColor(PIXELS,
    me-&gt;red / 255.0 * me-&gt;brightness,
    me-&gt;green / 255.0 * me-&gt;brightness,
    me-&gt;blue / 255.0 * me-&gt;brightness);</entry>
      <exit brief="dec brightness, check dimming direction">me-&gt;brightness = me-&gt;brightness - 8U;

if (me-&gt;brightness &lt; 10U) {
    me-&gt;dim_up = 0U;
}</exit>
      <state_glyph node="26,74,14,14">
       <entry box="1,2,13,4"/>
       <exit box="1,6,13,6"/>
      </state_glyph>
     </state>
     <state name="rainbow">
      <documentation>adapted from Nick Gammon</documentation>
      <entry brief="rainbow">// cycle the starting point
if (me-&gt;rain_x &gt;= 256) {
    me-&gt;rain_x = 0;
}
else {
    me-&gt;rain_x++;
}

// build into in-memory array, as these calculations take too long to do on the fly
for (me-&gt;led_index = 0; me-&gt;led_index &lt; PIXELS; me-&gt;led_index++) {
    byte r, g, b;
    Wheel ((me-&gt;led_index + me-&gt;rain_x) &amp; 255, r, g, b);
    pixelArray [me-&gt;led_index].r = r;
    pixelArray [me-&gt;led_index].g = g;
    pixelArray [me-&gt;led_index].b = b;
}

// now show results
QF_INT_DISABLE();
for (me-&gt;led_index = 0; me-&gt;led_index &lt; PIXELS; me-&gt;led_index++) {
    sendPixel (pixelArray [me-&gt;led_index].r, pixelArray [me-&gt;led_index].g, pixelArray [me-&gt;led_index].b);
}
QF_INT_ENABLE();

show();
// end of for each cycle</entry>
      <state_glyph node="26,90,14,6">
       <entry box="1,2,10,2"/>
      </state_glyph>
     </state>
     <state_glyph node="4,2,38,100">
      <entry box="1,2,25,6"/>
      <exit box="1,8,21,2"/>
     </state_glyph>
    </state>
    <state name="communication">
     <documentation>Because of the asynchronous communication a timer is startet. If it shoots the receive buffer is checked for the start sign.
If the start sign is detected the processing of the data starts.</documentation>
     <entry brief="start communication tick">QActive_armX((QActive *)me, 0U, COMMUNICATION_TICK, 0U);</entry>
     <exit brief="stop communication tick">QActive_disarmX((QActive *)me, 0U);</exit>
     <tran trig="Q_TIMEOUT">
      <choice target="../../1">
       <guard brief="detect_start_sign">Serial.read() == '&lt;'</guard>
       <action brief="init value">me-&gt;value = 0U;</action>
       <choice_glyph conn="57,26,4,3,6,2">
        <action box="0,1,20,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="46,26,3,-1,11">
       <action box="0,-2,11,2"/>
      </tran_glyph>
     </tran>
     <state name="process_data">
      <documentation>For processing the message char by char the value has to be transmitted first, because it is assigned with the incoming of the colour or program order.

Data format of the communication = &lt;XY&gt; (all type of char)
&lt; = start sign
X = value
Y = colour, program
&gt; = stop sign

With the detecting of the stop sign it is changed back to the branch state with its LED control programs.

On exit an acknowledge is send to the handy.</documentation>
      <entry brief="value, colour, program, stop sign">while (Serial.available()) {
    uint8_t data = Serial.read();
    switch (data) {
        case '0' ... '9':
            me-&gt;value *= 10;
            me-&gt;value += data - '0';
            break;
        case 'r':
            me-&gt;red = me-&gt;value;
            break;
        case 'g':
            me-&gt;green = me-&gt;value;
            break;
        case 'b':
            me-&gt;blue = me-&gt;value;
            break;
        case 'p':
            me-&gt;program = me-&gt;value;
            break;
        case '&gt;':
            QACTIVE_POST((QActive *)me, STOP_SIG, 0U);
            break;
    }
}</entry>
      <exit brief="acknowledge communication">Serial.print(F(&quot;A&quot;));</exit>
      <tran trig="STOP" target="../../../1">
       <tran_glyph conn="77,46,1,3,-33,58,-42,-98,2">
        <action box="-5,-2,6,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="59,30,18,18">
       <entry box="1,2,15,6"/>
       <exit box="1,8,12,4"/>
      </state_glyph>
     </state>
     <state_glyph node="46,14,33,36">
      <entry box="1,2,20,4"/>
      <exit box="1,6,21,2"/>
     </state_glyph>
    </state>
    <state_diagram size="81,106"/>
   </statechart>
  </class>
 </package>
 <directory name=".">
  <file name="LEDviaApp.ino">
   <text>#include &quot;qpn.h&quot;                       // QP-nano framework
#include &quot;Arduino.h&quot;                   // Arduino API

#include &lt;NeoPixels_SPI.h&gt;             // from Nick Gammon
#include &lt;SPI.h&gt;                       // Pin 11 = MOSI

//============================================================================
// declare all AO classes...
$declare(AOs::LEDviaApp)
//...

// AO instances and event queue buffers for them...
LEDviaApp AO_LEDviaApp;
static QEvt l_ledviaappQSto[10]; // Event queue storage for LEDviaApp
//...

//============================================================================
// QF_active[] array defines all active object control blocks ----------------
QActiveCB const Q_ROM QF_active[] = {
    { (QActive *)0,             (QEvt *)0,       0U                     },
    { (QActive *)&amp;AO_LEDviaApp, l_ledviaappQSto, Q_DIM(l_ledviaappQSto) }
};

//============================================================================
// various constants for the application...
enum {
// number of system clock ticks in one second
    BSP_TICKS_PER_SEC      = 100,

    COMMUNICATION_TICK     = BSP_TICKS_PER_SEC / 5U, // handshake timing 20 ms

//    PIXELS = 120,                      // number of LEDs in the stripe
    PIXELS = 8,                        // number of LED in the stick

    BLUETOOTH_POWER = 4,               // Pin of the transitor base
    LED_L = 13                         // pin number of on-board LED (L)
};

// various signals for the application...
enum {
    STOP_SIG        = Q_USER_SIG,      // end of data
    COMMUNICATION_SIG,                 // communication request
    DISPLAY_SIG,                       // display colour
    RUNNING_SIG,                       // running light animation
    DIMMING_SIG,                       // dimming animation
    RAINBOW_SIG                        // rainbow animation
};

// store the rainbox in memory
// WARNING! 3 bytes per pixel - take care you don't exceed available RAM
colour pixelArray [PIXELS];

//............................................................................
void setup() {
    // initialize the QF-nano framework
    QF_init(Q_DIM(QF_active));

    // initialize all AOs...
    QActive_ctor(&amp;AO_LEDviaApp.super, Q_STATE_CAST(&amp;LEDviaApp_initial));

    // initialize the hardware used in this sketch...
    pinMode(LED_L, OUTPUT);            // set the LED-L pin to output

    pinMode(BLUETOOTH_POWER, OUTPUT);  // Pin mode of the transitor control
    delay(3000);                       // switch on delay for program upload
    digitalWrite(BLUETOOTH_POWER, HIGH); // switch on the Bluetooth module

    // set the highest standard baud rate of 115200 bps
    Serial.begin(115200);

    ledsetup();                        // setup SPI
    showColor(PIXELS, 0, 0, 0);        // all LED off
}

//............................................................................
void loop() {
    QF_run(); // run the QF-nano framework
}

//============================================================================
// interrupts...
ISR(TIMER2_COMPA_vect) {
    QF_tickXISR(0U); // process time events for tick rate 0
}

//============================================================================
// QF callbacks...
void QF_onStartup(void) {
    // set Timer2 in CTC mode, 1/1024 prescaler, start the timer ticking...
    TCCR2A = (1U &lt;&lt; WGM21) | (0U &lt;&lt; WGM20);
    TCCR2B = (1U &lt;&lt; CS22 ) | (1U &lt;&lt; CS21) | (1U &lt;&lt; CS20); // 1/2^10
    ASSR  &amp;= ~(1U &lt;&lt; AS2);
    TIMSK2 = (1U &lt;&lt; OCIE2A); // enable TIMER2 compare Interrupt
    TCNT2  = 0U;

    // set the output-compare register based on the desired tick frequency
    OCR2A  = (F_CPU / BSP_TICKS_PER_SEC / 1024U) - 1U;
}

//............................................................................
void QV_onIdle(void) { // called with interrupts DISABLED
    // Put the CPU and peripherals to the low-power mode. You might
    // need to customize the clock management for your application,
    // see the datasheet for your particular AVR MCU.
    SMCR = (0 &lt;&lt; SM0) | (1 &lt;&lt; SE); // idle mode, adjust to your project
    QV_CPU_SLEEP(); // atomically go to sleep and enable interrupts
}

//............................................................................
void Q_onAssert(char const Q_ROM * const file, int line) {
    // implement the error-handling policy for your application!!!
    QF_INT_DISABLE(); // disable all interrupts
    QF_RESET(); // reset the CPU
}

//============================================================================
// define all AO classes (state machine)...
$define(AOs::LEDviaApp)
//...</text>
  </file>
 </directory>
</model>
