<?xml version="1.0" encoding="UTF-8"?>
<model version="4.0.3" links="0">
 <documentation>Prototyp of controlling a LED stripe with an Arduino from a handy with Bluetooth communication.
Because of the reason that the Bluetooth communication needs interrupts but the controlling of the LED stripe forbids it the communication and the controlling has to be split into two branches.

To set the 120 pixel LED stripe there are around 369 µs of time needed (according to Nick Gammon).
The communication check time tick has to be longer than this to not disturb the setting. For now the communication tick is 20 ms long.

Calculations:
1 SPI bit = two processor clock cycles = 16 MHz / 2 = 8 MHz = 8000000 * 1 / s = 1 / 8000000 s = 0,000000125 s = 0,000125 µs = 0,125 ms = 125 ns
1 byte = 8 * SPI bit = 8 * 125 ns = 1000 ns
1 rgb-pixel = 3 * byte = 3 * 1000 ns = 3000 ns
120 rgb-pixel = 120 * rgb-pixel = 120 * 3000 ns = 360000 ns = 360 µs = 0,36 ms
LED stripe setzen = 120 prgb-ixel + 9 µs reset = 360 µs + 9 µs = 369 µs = 0,369 ms

The stopping of the communication tick with &quot;QActive_disarmX((QActive *)me, 0U);&quot; is optinal because the timer is an one shot event. But the author of the framework supposes it because of a clean programming.</documentation>
 <framework name="qpn"/>
 <package name="AOs" stereotype="0x02">
  <class name="LEDviaApp" superclass="qpn::QActive">
   <documentation>use for debuging:
digitalWrite(DEBUG_LED, HIGH);
digitalWrite(DEBUG_LED, LOW);</documentation>
   <attribute name="value" type="uint8_t" visibility="0x02" properties="0x00"/>
   <attribute name="red" type="uint8_t" visibility="0x02" properties="0x00"/>
   <attribute name="green" type="uint8_t" visibility="0x02" properties="0x00"/>
   <attribute name="blue" type="uint8_t" visibility="0x02" properties="0x00"/>
   <attribute name="program" type="uint8_t" visibility="0x02" properties="0x00"/>
   <attribute name="led_index" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>index of the LED in the stripe</documentation>
   </attribute>
   <attribute name="led_x" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>processed LED</documentation>
   </attribute>
   <attribute name="run_fwd" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>flag for running light direction
0U = forward, else backward</documentation>
   </attribute>
   <attribute name="brightness" type="uint8_t" visibility="0x02" properties="0x00"/>
   <attribute name="dim_up" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>flag for dimming direction
0U = up, else down</documentation>
   </attribute>
   <statechart>
    <initial target="../1">
     <initial_glyph conn="2,2,4,3,2,2">
      <action box="1,-2,4,2"/>
     </initial_glyph>
    </initial>
    <state name="branch">
     <documentation>First it is checked whether there is a request from the handy in the receive buffer of the USART. If so a transmit order is send to the handy and it is changed into the communication state. If not it is changed into  the active program substate.

Periodically a time tick is generated to recheck the receive buffer. This timer is also used to progress the LED programs with animations.</documentation>
     <entry brief="communication check, program choice, start communication tick">if (Serial.read() == 'R') {
    Serial.print(F(&quot;T&quot;));
    QACTIVE_POST((QActive *)me, COMMUNICATION_SIG, 0U);
}
else {
    if (me-&gt;program == 1)
        QACTIVE_POST((QActive *)me, DISPLAY_SIG, 0U);
    else if (me-&gt;program == 2)
        QACTIVE_POST((QActive *)me, RUNNING_LIGHT_SIG, 0U);
    else if (me-&gt;program == 3)
        QACTIVE_POST((QActive *)me, DIMMING_SIG, 0U);
}

QActive_armX((QActive *)me, 0U, COMMUNICATION_TICK, 0U);</entry>
     <exit brief="stop communication tick">QActive_disarmX((QActive *)me, 0U);</exit>
     <tran trig="COMMUNICATION" target="../../2">
      <tran_glyph conn="4,16,3,3,43">
       <action box="0,-2,14,2"/>
      </tran_glyph>
     </tran>
     <tran trig="DISPLAY" target="../5">
      <tran_glyph conn="4,20,3,3,22">
       <action box="0,-2,9,2"/>
      </tran_glyph>
     </tran>
     <tran trig="RUNNING_LIGHT">
      <choice target="../../6">
       <guard brief="fwd">!me-&gt;run_fwd</guard>
       <choice_glyph conn="20,28,5,3,6">
        <action box="1,-2,6,2"/>
       </choice_glyph>
      </choice>
      <choice target="../../7">
       <guard brief="bwd">else</guard>
       <choice_glyph conn="20,28,4,3,16,6">
        <action box="0,14,7,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="4,28,3,-1,16">
       <action box="0,-2,14,2"/>
      </tran_glyph>
     </tran>
     <tran trig="DIMMING">
      <choice target="../../8">
       <guard brief="up">!me-&gt;dim_up</guard>
       <choice_glyph conn="14,60,5,3,12">
        <action box="1,-2,5,2"/>
       </choice_glyph>
      </choice>
      <choice target="../../9">
       <guard brief="down">else</guard>
       <choice_glyph conn="14,60,4,3,14,12">
        <action box="0,12,7,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="4,60,3,-1,10">
       <action box="0,-2,8,2"/>
      </tran_glyph>
     </tran>
     <tran trig="Q_TIMEOUT" target="..">
      <tran_glyph conn="43,88,1,3,-39">
       <action box="-10,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state name="display">
      <entry brief="display LED">showColor(PIXELS, me-&gt;red, me-&gt;green, me-&gt;blue);</entry>
      <state_glyph node="26,18,15,6">
       <entry box="1,2,13,2"/>
      </state_glyph>
     </state>
     <state name="running_fwd">
      <documentation>Because of the strict timing of the SPI bus while sending the colour values to the whole LED stripe the interrupts has to be shut off. At the end of the sending a short blocking dealy is necessary as a reset for the stripe to show the colours (s. Nick Gammon).

At exit the processed LED is incremented.
If the LED index reaches the end of the stripe, the direction flag is set true to change the direction.</documentation>
      <entry brief="running LED">QF_INT_DISABLE();
for (me-&gt;led_index = 0U; me-&gt;led_index &lt; PIXELS; me-&gt;led_index++) {
    if (me-&gt;led_index == me-&gt;led_x) {
        sendPixel(me-&gt;red, me-&gt;green, me-&gt;blue);
        }
    else {
        sendPixel(0U, 0U, 0U);
        }
}
QF_INT_ENABLE();

show();</entry>
      <exit brief="inc processed LED, check running direction">me-&gt;led_x++;

if (me-&gt;led_x == PIXELS - 1U) {
    me-&gt;run_fwd = 1U;
    }</exit>
      <state_glyph node="26,26,15,14">
       <entry box="1,2,14,4"/>
       <exit box="1,6,14,6"/>
      </state_glyph>
     </state>
     <state name="running_bwd">
      <documentation>Because of the strict timing of the SPI bus while sending the colour values to the whole LED stripe the interrupts has to be shut off. At the end of the sending a short blocking dealy is necessary as a reset for the stripe to show the colours (s. Nick Gammon).

At exit the processed LED is decremented.
If the LED index reaches the beginning of the stripe, the direction flag is set false to change the direction.</documentation>
      <entry brief="running LED">QF_INT_DISABLE();
for (me-&gt;led_index = 0U; me-&gt;led_index &lt; PIXELS; me-&gt;led_index++) {
    if (me-&gt;led_index == me-&gt;led_x) {
        sendPixel(me-&gt;red, me-&gt;green, me-&gt;blue);
        }
    else {
        sendPixel(0U, 0U, 0U);
        }
}
QF_INT_ENABLE();

show();</entry>
      <exit brief="inc processed LED, check running direction">me-&gt;led_x--;

if (me-&gt;led_x == 0U) {
    me-&gt;run_fwd = 0U;
    }</exit>
      <state_glyph node="26,42,15,14">
       <entry box="1,2,14,4"/>
       <exit box="1,6,14,6"/>
      </state_glyph>
     </state>
     <state name="dimming_up">
      <documentation>The colours are multiplicated with an incrementing brightness value.

At exit the brightness is incremented.
If the brightness reaches an upper limit, the direction flag is set true to change the direction.</documentation>
      <entry brief="dimming LED">showColor(PIXELS,
    me-&gt;red / 255.0 * me-&gt;brightness,
    me-&gt;green / 255.0 * me-&gt;brightness,
    me-&gt;blue / 255.0 * me-&gt;brightness);</entry>
      <exit brief="inc brightness, check direction">me-&gt;brightness = me-&gt;brightness + 4U;

if (me-&gt;brightness &gt; 250U) {
    me-&gt;dim_up = 1U;
    }</exit>
      <state_glyph node="26,58,14,12">
       <entry box="1,2,13,4"/>
       <exit box="1,6,13,4"/>
      </state_glyph>
     </state>
     <state name="dimming_down">
      <documentation>The colours are multiplicated with an decrementing brightness value.

At exit the brightness is decremented.
If the brightness reaches a lower limit, the direction flag is set false to change the direction.</documentation>
      <entry brief="dimming LED">showColor(PIXELS,
    me-&gt;red / 255.0 * me-&gt;brightness,
    me-&gt;green / 255.0 * me-&gt;brightness,
    me-&gt;blue / 255.0 * me-&gt;brightness);</entry>
      <exit brief="dec brightness, check direction">me-&gt;brightness = me-&gt;brightness - 4U;

if (me-&gt;brightness &lt; 10U) {
    me-&gt;dim_up = 0U;
    }</exit>
      <state_glyph node="26,72,14,12">
       <entry box="1,2,13,4"/>
       <exit box="1,6,13,4"/>
      </state_glyph>
     </state>
     <state_glyph node="4,2,39,88">
      <entry box="1,2,26,6"/>
      <exit box="1,8,21,2"/>
     </state_glyph>
    </state>
    <state name="communication">
     <documentation>Because of the asynchronous communication a timer is startet. If it shoots the receive buffer is checked for the start sign.
If the start sign is detected the processing of the data starts.</documentation>
     <entry brief="start communication tick">QActive_armX((QActive *)me, 0U, COMMUNICATION_TICK, 0U);</entry>
     <exit brief="stop communication tick">QActive_disarmX((QActive *)me, 0U);</exit>
     <tran trig="Q_TIMEOUT">
      <choice target="../../1">
       <guard brief="detect_start_sign">Serial.read() == '&lt;'</guard>
       <action brief="init value">me-&gt;value = 0U;</action>
       <choice_glyph conn="58,26,4,3,6,2">
        <action box="0,1,20,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="47,26,3,-1,11">
       <action box="0,-2,11,2"/>
      </tran_glyph>
     </tran>
     <state name="process_data">
      <documentation>For processing the message char by char the value has to be transmitted first, because it is assigned with the incoming of the colour or program order.

Data format of the communication = &lt;XY&gt; (all type of char)
&lt; = start sign
X = value
Y = colour, program
&gt; = stop sign

With the detecting of the stop sign it is changed back to the branch state with its LED control programs.

On exit an acknowledge is send to the handy.</documentation>
      <entry brief="value, colour, program, stop sign">while (Serial.available()) {
    uint8_t data = Serial.read();
    switch (data) {
        case '0' ... '9':
            me-&gt;value *= 10;
            me-&gt;value += data - '0';
            break;
        case 'r':
            me-&gt;red = me-&gt;value;
            break;
        case 'g':
            me-&gt;green = me-&gt;value;
            break;
        case 'b':
            me-&gt;blue = me-&gt;value;
            break;
        case 'p':
            me-&gt;program = me-&gt;value;
            break;
        case '&gt;':
            QACTIVE_POST((QActive *)me, STOP_SIG, 0U);
            break;
    }
}</entry>
      <exit brief="acknowledge communication">Serial.print(F(&quot;A&quot;));</exit>
      <tran trig="STOP" target="../../../1">
       <tran_glyph conn="78,46,1,3,-33,46,-43,-86,2">
        <action box="-5,-2,6,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="60,30,18,18">
       <entry box="1,2,15,6"/>
       <exit box="1,8,12,4"/>
      </state_glyph>
     </state>
     <state_glyph node="47,14,33,36">
      <entry box="1,2,20,4"/>
      <exit box="1,6,21,2"/>
     </state_glyph>
    </state>
    <state_diagram size="83,94"/>
   </statechart>
  </class>
 </package>
 <directory name=".">
  <file name="LEDviaApp.ino">
   <text>#include &quot;qpn.h&quot;                       // QP-nano framework
#include &quot;Arduino.h&quot;                   // Arduino API

#include &lt;NeoPixels_SPI.h&gt;             // from Nick Gammon
#include &lt;SPI.h&gt;                       // Pin 11 = MOSI

//============================================================================
// declare all AO classes...
$declare(AOs::LEDviaApp)
//...

// AO instances and event queue buffers for them...
LEDviaApp AO_LEDviaApp;
static QEvt l_ledviaappQSto[10]; // Event queue storage for LEDviaApp
//...

//============================================================================
// QF_active[] array defines all active object control blocks ----------------
QActiveCB const Q_ROM QF_active[] = {
    { (QActive *)0,             (QEvt *)0,       0U                     },
    { (QActive *)&amp;AO_LEDviaApp, l_ledviaappQSto, Q_DIM(l_ledviaappQSto) }
};

//============================================================================
// various constants for the application...
enum {
// number of system clock ticks in one second
    BSP_TICKS_PER_SEC       = 100,

    COMMUNICATION_TICK     = BSP_TICKS_PER_SEC / 5U, // 20 ms

//    PIXELS = 120,                      // number of LEDs in the stripe
    PIXELS = 8,                        // number of LED in the stick

    BLUETOOTH_POWER = 4,               // Pin of the transitor base

    STOP_SIG,                          // end of data

    COMMUNICATION_SIG,                 // communication request
    DISPLAY_SIG,                       // display colour
    RUNNING_LIGHT_SIG,                 // running light animation
    DIMMING_SIG,                       // dimming animation
    DEBUG_LED = 7                      // optional debuging LED
};

//............................................................................
void setup() {
    // initialize the QF-nano framework
    QF_init(Q_DIM(QF_active));

    // initialize all AOs...
    QActive_ctor(&amp;AO_LEDviaApp.super, Q_STATE_CAST(&amp;LEDviaApp_initial));

    // initialize the hardware used in this sketch...
    pinMode(DEBUG_LED, OUTPUT);        // set the DEBUG_LED pin to output

    pinMode(BLUETOOTH_POWER, OUTPUT);  // Pin mode of the transitor control
    delay(3000);                       // switch on delay for program upload
    digitalWrite(BLUETOOTH_POWER, HIGH); // switch on the Bluetooth module

    // set the highest standard baud rate of 115200 bps
    Serial.begin(115200);

    ledsetup();                        // setup SPI
    showColor(PIXELS, 0, 0, 0);        // all LED off
}

//............................................................................
void loop() {
    QF_run(); // run the QF-nano framework
}

//============================================================================
// interrupts...
ISR(TIMER2_COMPA_vect) {
    QF_tickXISR(0U); // process time events for tick rate 0
}

//============================================================================
// QF callbacks...
void QF_onStartup(void) {
    // set Timer2 in CTC mode, 1/1024 prescaler, start the timer ticking...
    TCCR2A = (1U &lt;&lt; WGM21) | (0U &lt;&lt; WGM20);
    TCCR2B = (1U &lt;&lt; CS22 ) | (1U &lt;&lt; CS21) | (1U &lt;&lt; CS20); // 1/2^10
    ASSR  &amp;= ~(1U &lt;&lt; AS2);
    TIMSK2 = (1U &lt;&lt; OCIE2A); // enable TIMER2 compare Interrupt
    TCNT2  = 0U;

    // set the output-compare register based on the desired tick frequency
    OCR2A  = (F_CPU / BSP_TICKS_PER_SEC / 1024U) - 1U;
}

//............................................................................
void QV_onIdle(void) { // called with interrupts DISABLED
    // Put the CPU and peripherals to the low-power mode. You might
    // need to customize the clock management for your application,
    // see the datasheet for your particular AVR MCU.
    SMCR = (0 &lt;&lt; SM0) | (1 &lt;&lt; SE); // idle mode, adjust to your project
    QV_CPU_SLEEP(); // atomically go to sleep and enable interrupts
}

//............................................................................
void Q_onAssert(char const Q_ROM * const file, int line) {
    // implement the error-handling policy for your application!!!
    QF_INT_DISABLE(); // disable all interrupts
    QF_RESET(); // reset the CPU
}

//============================================================================
// define all AO classes (state machine)...
$define(AOs::LEDviaApp)
//...</text>
  </file>
 </directory>
</model>
