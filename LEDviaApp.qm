<?xml version="1.0" encoding="UTF-8"?>
<model version="4.0.1" links="0">
 <documentation>Grundgerüst für die Ansteuerung einer LED-Kette mit dem Arduino UNO.
Die Werte kommen per Bluetooth von einer Handy-App.
Da die Ansteuerung der LEDs zeitkritisch ist, darf während dessen keine andere Aktivität laufen. Vor allen Dingen würde es Konflikte mit einer gleichzeitigen Kommunikation zwischen der Handy-App und dem Arduino geben. Deshalb wird nur ein in der Hardware laufender Timer im Hintergrund gestartet, um von Zeit zu Zeit nachzuschauen, ob eine Kommunikationsanfrage von der Handy-App im ebenfalls im Hintergrund laufenden Empfangsspeicher liegt. Entsprechend wird dann in die Kommunikation verzweigt, um den neuen Befehl von der Handy-App zu bekommen oder zurück in die LED-Ansteuerung verzweigt.

Das Stoppen des Kommunikations-Timers mit QActive_disarmX((QActive *)me, 0U);
ist an sich nicht nötig, da der Timer ein One-Shot-Ereignis ist, also nicht wieder gestartet wird, aber es wird von Miro Samek als &quot;sauberer&quot; Programmierstil empfohlen.</documentation>
 <framework name="qpn"/>
 <package name="AOs" stereotype="0x02">
  <class name="LEDviaApp" superclass="qpn::QActive">
   <documentation>digitalWrite(DEBUG_LED, HIGH);
digitalWrite(DEBUG_LED, LOW);</documentation>
   <attribute name="value" type="uint8_t" visibility="0x02" properties="0x00"/>
   <attribute name="red" type="uint8_t" visibility="0x02" properties="0x00"/>
   <attribute name="green" type="uint8_t" visibility="0x02" properties="0x00"/>
   <attribute name="blue" type="uint8_t" visibility="0x02" properties="0x00"/>
   <attribute name="program" type="uint8_t" visibility="0x02" properties="0x00"/>
   <attribute name="led_index" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>index of the LED in the stripe</documentation>
   </attribute>
   <attribute name="led_x" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>processed LED</documentation>
   </attribute>
   <attribute name="brightness" type="uint8_t" visibility="0x02" properties="0x00"/>
   <statechart>
    <initial target="../1">
     <initial_glyph conn="2,2,4,3,2,2">
      <action box="1,-2,4,2"/>
     </initial_glyph>
    </initial>
    <state name="branch">
     <documentation>Zuerst wird geprüft, ob im Serial receive buffer ein 'R' als Übertragungsanfrage der App steht. Wenn ja, wird ein &quot;T&quot; als Übertragungsfreigabe gesendet und in den State Kommunikation verzweigt.
Ansonsten wird in das zuletzt aktive Programm verzweigt.</documentation>
     <entry brief="communication check, program choice, start communication tick">if (Serial.read() == 'R') {
    Serial.print(F(&quot;T&quot;));
    QACTIVE_POST((QActive *)me, COMMUNICATION_SIG, 0U);
}
else {
    if (me-&gt;program == 1)
        QACTIVE_POST((QActive *)me, DISPLAY_SIG, 0U);
    else if (me-&gt;program == 2)
        QACTIVE_POST((QActive *)me, RUNNING_LIGHT_SIG, 0U);
    else if (me-&gt;program == 3)
        QACTIVE_POST((QActive *)me, DIMMING_SIG, 0U);
}

QActive_armX((QActive *)me, 0U, COMMUNICATION_TICK, 0U);</entry>
     <exit brief="stop communication tick">QActive_disarmX((QActive *)me, 0U);</exit>
     <tran trig="COMMUNICATION" target="../../2">
      <tran_glyph conn="4,16,3,3,35">
       <action box="0,-2,14,2"/>
      </tran_glyph>
     </tran>
     <tran trig="DISPLAY" target="../5">
      <tran_glyph conn="4,20,3,3,14">
       <action box="0,-2,9,2"/>
      </tran_glyph>
     </tran>
     <tran trig="RUNNING_LIGHT" target="../6">
      <tran_glyph conn="4,28,3,3,14">
       <action box="0,-2,14,2"/>
      </tran_glyph>
     </tran>
     <tran trig="DIMMING" target="../7">
      <tran_glyph conn="4,40,3,3,14">
       <action box="0,-2,8,2"/>
      </tran_glyph>
     </tran>
     <tran trig="Q_TIMEOUT" target="..">
      <tran_glyph conn="35,50,1,3,-31">
       <action box="-10,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state name="display">
      <entry brief="display LED">showColor(PIXELS, me-&gt;red, me-&gt;green, me-&gt;blue);</entry>
      <state_glyph node="18,18,15,6">
       <entry box="1,2,13,2"/>
      </state_glyph>
     </state>
     <state name="running_light">
      <documentation>Vor jedem Beschreiben des LED-stripes müssen die Interrupts abgeschaltet werden, damit das Timing über den SPI-Bus nicht gestört wird (s. Nick Gammon).
Am Ende wird der LED-Index bis zum Maximum der LEDs erhöht.</documentation>
      <entry brief="init LED index, LED running light, inc LED index">if (me-&gt;led_index == PIXELS) {
    me-&gt;led_index = 0U;
    }

QF_INT_DISABLE();
for (me-&gt;led_x = 0U; me-&gt;led_x &lt; PIXELS; me-&gt;led_x++) {
    if (me-&gt;led_x == me-&gt;led_index) {
        sendPixel(me-&gt;red, me-&gt;green, me-&gt;blue);
        }
    else {
        sendPixel(0U, 0U, 0U);
        }
}
QF_INT_ENABLE();

show();

me-&gt;led_index++;</entry>
      <state_glyph node="18,26,14,10">
       <entry box="1,2,13,6"/>
      </state_glyph>
     </state>
     <state name="dimming">
      <documentation>Am Ende wird die Helligkeit bis zum Überlauf erhöht.</documentation>
      <entry brief="dimming LED , inc brightness">showColor(PIXELS,
    me-&gt;red / 255.0 * me-&gt;brightness,
    me-&gt;green / 255.0 * me-&gt;brightness,
    me-&gt;blue / 255.0 * me-&gt;brightness);

me-&gt;brightness = me-&gt;brightness + 8U;</entry>
      <state_glyph node="18,38,14,8">
       <entry box="1,2,13,4"/>
      </state_glyph>
     </state>
     <state_glyph node="4,2,31,50">
      <entry box="1,2,26,6"/>
      <exit box="1,8,21,2"/>
     </state_glyph>
    </state>
    <state name="communication">
     <documentation>Da die App (, bzw. das Handy) nicht so schnell auf die Übertragungsfreigabe reagieren kann (asynchrone Kommunikation), wird erst ein Timer gestartet.
Wenn nach Ablauf des Timers im Serial receive buffer das Startzeichen '&lt;' erkannt wird, beginnt das Verarbeiten der Daten in Farb- oder Programmwerte.
Die Variable wert wird genullt.</documentation>
     <entry brief="start communication tick">QActive_armX((QActive *)me, 0U, COMMUNICATION_TICK, 0U);</entry>
     <exit brief="stop communication tick">QActive_disarmX((QActive *)me, 0U);</exit>
     <tran trig="Q_TIMEOUT">
      <choice target="../../1">
       <guard brief="detect_start_sign">Serial.read() == '&lt;'</guard>
       <action brief="init value">me-&gt;value = 0U;</action>
       <choice_glyph conn="50,26,4,3,6,2">
        <action box="0,1,20,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="39,26,3,-1,11">
       <action box="0,-2,11,2"/>
      </tran_glyph>
     </tran>
     <state name="process_data">
      <documentation>Datenformat für die Farbe und das Programm:
XY, XXY, XXXY
X    = Wert
Y    = Farbe, Programm
Es wird pro Kommunikationszyklus nur ein Wert und die Farbe oder ein Wert und das Programm übertragen.
Mit dem Stoppzeichen '&gt;' endet das Paket und es wird ein 'A' an die App übertragen, als Signal für das Kommunikationsende.
Dann wird in den State Verzweigung gesprungen.</documentation>
      <entry brief="value, colour, program, STOPP">while (Serial.available()) {
    uint8_t data = Serial.read();
    switch (data) {
        case '0' ... '9':
            me-&gt;value *= 10;
            me-&gt;value += data - '0';
            break;
        case 'r':
            me-&gt;red = me-&gt;value;
            break;
        case 'g':
            me-&gt;green = me-&gt;value;
            break;
        case 'b':
            me-&gt;blue = me-&gt;value;
            break;
        case 'p':
            me-&gt;program = me-&gt;value;
            break;
        case '&gt;':
            QACTIVE_POST((QActive *)me, STOPP_SIG, 0U);
            break;
    }
}</entry>
      <tran trig="STOPP" target="../../../1">
       <action brief="acknowledge communication ">Serial.print(F(&quot;A&quot;));</action>
       <tran_glyph conn="70,42,1,3,-33,12,-35,-48,2">
        <action box="-16,-4,16,4"/>
       </tran_glyph>
      </tran>
      <state_glyph node="52,30,18,14">
       <entry box="1,2,15,4"/>
      </state_glyph>
     </state>
     <state_glyph node="39,14,33,32">
      <entry box="1,2,20,4"/>
      <exit box="1,6,21,2"/>
     </state_glyph>
    </state>
    <state_diagram size="75,57"/>
   </statechart>
  </class>
 </package>
 <directory name=".">
  <file name="LEDviaApp.ino">
   <text>#include &quot;qpn.h&quot;                       // QP-nano framework
#include &quot;Arduino.h&quot;                   // Arduino API

#include &lt;NeoPixels_SPI.h&gt;             // from Nick Gammon
#include &lt;SPI.h&gt;                       // Pin 11 = MOSI

//============================================================================
// declare all AO classes...
$declare(AOs::LEDviaApp)
//...

// AO instances and event queue buffers for them...
LEDviaApp AO_LEDviaApp;
static QEvt l_ledviaappQSto[10]; // Event queue storage for LEDviaApp
//...

//============================================================================
// QF_active[] array defines all active object control blocks ----------------
QActiveCB const Q_ROM QF_active[] = {
    { (QActive *)0,             (QEvt *)0,       0U                     },
    { (QActive *)&amp;AO_LEDviaApp, l_ledviaappQSto, Q_DIM(l_ledviaappQSto) }
};

//============================================================================
// various constants for the application...
enum {
// number of system clock ticks in one second
    BSP_TICKS_PER_SEC       = 100,

    COMMUNICATION_TICK     = BSP_TICKS_PER_SEC / 5U,

    PIXELS = 120,                      // number of LED

    BLUETOOTH_POWER = 4,               // Pin of the transitor control

    STOPP_SIG,                         // end of data

    COMMUNICATION_SIG,
    DISPLAY_SIG,
    RUNNING_LIGHT_SIG,
    DIMMING_SIG,

    DEBUG_LED = 7                      // optional debugging LED
};

//............................................................................
void setup() {
    // initialize the QF-nano framework
    QF_init(Q_DIM(QF_active));

    // initialize all AOs...
    QActive_ctor(&amp;AO_LEDviaApp.super, Q_STATE_CAST(&amp;LEDviaApp_initial));

    // initialize the hardware used in this sketch...
    pinMode(DEBUG_LED, OUTPUT); // set the DEBUG_LED pin to output

    pinMode(BLUETOOTH_POWER, OUTPUT);  // Pin mode of the transitor control
    delay(3000);                       // switch on delay for program upload
    digitalWrite(BLUETOOTH_POWER, HIGH); // switch on the Bluetooth module

    Serial.begin(115200); // set the highest standard baud rate of 115200 bps

    ledsetup();                        // setup SPI
    showColor(PIXELS, 0, 0, 0);        // all Led off
}

//............................................................................
void loop() {
    QF_run(); // run the QF-nano framework
}

//============================================================================
// interrupts...
ISR(TIMER2_COMPA_vect) {
    QF_tickXISR(0U); // process time events for tick rate 0
}

//============================================================================
// QF callbacks...
void QF_onStartup(void) {
    // set Timer2 in CTC mode, 1/1024 prescaler, start the timer ticking...
    TCCR2A = (1U &lt;&lt; WGM21) | (0U &lt;&lt; WGM20);
    TCCR2B = (1U &lt;&lt; CS22 ) | (1U &lt;&lt; CS21) | (1U &lt;&lt; CS20); // 1/2^10
    ASSR  &amp;= ~(1U &lt;&lt; AS2);
    TIMSK2 = (1U &lt;&lt; OCIE2A); // enable TIMER2 compare Interrupt
    TCNT2  = 0U;

    // set the output-compare register based on the desired tick frequency
    OCR2A  = (F_CPU / BSP_TICKS_PER_SEC / 1024U) - 1U;
}

//............................................................................
void QV_onIdle(void) { // called with interrupts DISABLED
    // Put the CPU and peripherals to the low-power mode. You might
    // need to customize the clock management for your application,
    // see the datasheet for your particular AVR MCU.
    SMCR = (0 &lt;&lt; SM0) | (1 &lt;&lt; SE); // idle mode, adjust to your project
    QV_CPU_SLEEP(); // atomically go to sleep and enable interrupts
}

//............................................................................
void Q_onAssert(char const Q_ROM * const file, int line) {
    // implement the error-handling policy for your application!!!
    QF_INT_DISABLE(); // disable all interrupts
    QF_RESET(); // reset the CPU
}

//============================================================================
// define all AO classes (state machine)...
$define(AOs::LEDviaApp)
//...
</text>
  </file>
 </directory>
</model>
